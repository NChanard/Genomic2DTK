---
title: "Genomic2DTK - Quick start"
author: "Nicolas Chanard"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
description: >
  Quick tutorial about Genomic2DTK functions.
vignette: >
  %\VignetteIndexEntry{Genomic2DTK - Quick start}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[UTF-8]{inputenc}
---
<style>
body {
text-align: justify}
</style>
```{css, echo=FALSE}
pre {
  max-height: 300px;
  overflow-y: auto;
}

pre[class] {
  max-height: 300px;
}
```
```{css, echo=FALSE}
.scroll-100 {
  max-height: 100px;
  overflow-y: auto;
  background-color: inherit;
}
```
```{r, Options, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(collapse = T, comment = "#>")
options(tibble.print_min = 4L, tibble.print_max = 4L)
```

# Library
Genomic2DTK is a package that allows to perform aggregation analyses. In a first step, these analyses consist in extracting 3D conformation data at specific genome loci. Then, in a second step, to aggregate the extracted signal on all the loci to visualize it. In this tutorial you will see how to quickly perform this type of analysis.
However, we invite you to have a closer look at the documentation and other articles that present in more depth the possibilities of Genomic2DTK which allows for example the exploration and quantification of the signal at a single locus or the performance of differential analysis.

## Install libraries
```{r, eval = FALSE}
remotes::install_github("NChanard/Genomic2DTK")
remotes::install_github("NChanard/GenomicED")
```

## Load libraries
```{r, eval = TRUE, message = FALSE}
library(Genomic2DTK)
library(GenomicED)
```  


# Test dataset
The testing dataset is obtained from *Drosophila melanogaster S2 cells*.
A first part of this data is provided directly in this package and it consist of genomic location data (ChIP-seq and annotations). An other part of testing dataset is downloaded directly from the [4DN](https://data.4dnucleome.org) platform and it consists of 3D structure data of the genome (HiC maps in two different conditions).

## Genomic location and annotation data
These kind of data could be import in R with [rtracklayer](https://bioconductor.org/packages/release/bioc/html/rtracklayer.html) package.

### ChIP-seq peaks
Subset of ChIP-seq peaks of Beaf-32 protein in wild type condition in GRanges format (bed).
```{r, eval = TRUE}
data("anchors_Peaks.gnr")
```
<details>  
<summary>View</summary>  
```{r, echo = FALSE, eval = TRUE, message = FALSE}
anchors_Peaks.dtf <- anchors_Peaks.gnr |> as.data.frame() |> head(n=3L)
anchors_Peaks.dtf <- anchors_Peaks.dtf[,-c(4)]
knitr::kable(anchors_Peaks.dtf[,c(1:4,6,5)],
  col.names = c(
    "seq","start","end","strand",
    "name","score"),
  align  = "rccccc",
  digits = 1
)
```
</details>  

### Reference annontation
Subset data of TSS from the UCSC data base ([TxDb.Dmelanogaster.UCSC.dm6.ensGene](https://bioconductor.org/packages/release/data/annotation/html/TxDb.Dmelanogaster.UCSC.dm6.ensGene.html)).
```{r, eval = TRUE}
data("baits_Peaks.gnr")
```
<details>
<summary>View</summary>
```{r, echo = FALSE, eval = TRUE, message = FALSE}
baits_Peaks.dtf <- baits_Peaks.gnr |> as.data.frame() |> head(n=3L)
baits_Peaks.dtf <- baits_Peaks.dtf[,-c(4)] 
knitr::kable(baits_Peaks.dtf[,c(1:4,6,5)],
  col.names = c(
    "seq","start","end","strand",
    "name","class"),
  align  = "rccccc"
)
```
</details>  

### Domains annotation
Subset of topologically associated domains from a TAD calling annalysis on wild-type HiC data ([F. Ramirez, 2018](https://doi.org/10.1038/s41467-017-02525-w)).
```{r, eval = TRUE}
data("domains.gnr")
```
<details>  
<summary>View</summary>  
```{r, echo = FALSE, eval = TRUE, message = FALSE}
domains.dtf <- domains.gnr |> as.data.frame() |> head(n=3L)
domains.dtf <- domains.dtf[,-c(4)]
knitr::kable(domains.dtf[,c(1:4,7,5,6)],
  col.names = c(
    "seq","start","end","strand",
    "name","score","class"),
  align  = "rcccccc"
  )
```
</details>  

## Genomic 3D structure
The second part of the test data is downloaded directly from the [4DN](https://data.4dnucleome.org) platform. It consists of data from HiC experiments.

### Prepare download
```{r, eval = TRUE, message = FALSE}
options(timeout = 3600) 
temp.dir <- file.path(tempdir(), "HIC_DATA")
dir.create(temp.dir)
```

### Map in control condition
HiC Map in .hic format (juicer format).
```{r, eval = TRUE, message = FALSE}
Hic.url <- "https://4dn-open-data-public.s3.amazonaws.com/fourfront-webprod/wfoutput/7386f953-8da9-47b0-acb2-931cba810544/4DNFIOTPSS3L.hic"
HicOutput.pth <- file.path(temp.dir, "Control_HIC.hic")
download.file(Hic.url, HicOutput.pth)
```

## Additional genome informations
General genomic informations used by the functions all along the process are a data.frame containing chromosomes names and sized and the binSize, corresponding to the HiC matrices resolution.
We complete the data with 2L and 2R chromosome sizes and HiC map resolution.
```{r, eval = TRUE}
seqlengths.num <- c('2L'=23513712, '2R'=25286936)
chromSize.dtf  <- data.frame(
  seqnames   = names(seqlengths.num ), 
  seqlengths = seqlengths.num
  )
binSize.num <- 1000
```





# HiC Preprocess
The package supports the preprocessing of HiC data and allows you to access the information in a simplified way thanks to the data structure.

## Import
Genomic2DTK can import HiC data stored in the main formats: .hic, .cool, .mcool, .h5, .hdf5.

```{r, eval = TRUE, results = FALSE}
hic.cmx_lst <- ImportHiC(
  file.pth      = HicOutput.pth,
  res.num       = binSize.num,
  chromSize.dtf = chromSize.dtf ,
  chrom_1.chr   = c("2L","2R")
  )
```


## Balancing
Genomic2TK forces the import in the R environment of the raw counts matrix, it is thus necessary to perform the balancing step (Defaut: Iterative Correction) which makes it possible to correct the biases inherent to the loci by balancing the sums of each line and of each column to make them comparable.
```{r, eval = TRUE, results = FALSE}
hic.cmx_lst <- NormalizeHiC(hic.cmx_lst)
```
## Expected
Once the bias inherent to the loci has been corrected, the bias due to the genomic distance between two loci must be corrected. To do this, the matrix is corrected by the expected values for each genomic distance.
```{r, eval = TRUE, results = FALSE}
hic.cmx_lst <- ExpectedHiC(hic.cmx_lst)
```

## HiC data format: ContactMatrix list (cmx_lst) structure 
Each element of the list corresponds to a ContactMatrix object (dgCMatrix object, sparse matrix format) storing contact frequencies for one chromosomes (cis-interactions, ex: "2L_2L") or between two chromosomes (trans-interactions, ex: "2L_2R").  
HiC data format is based on [InteractionSet](https://www.bioconductor.org/packages/release/bioc/vignettes/InteractionSet/inst/doc/interactions.html) package, for more details on sparse matrices format, see [Matrix](https://cran.r-project.org/web/packages/Matrix/Matrix.pdf).
```{r, eval = TRUE}
str(HiC_ctrl.cmx_lst, max.level = 4)
#>
```
The list object have some generals attributes. These attributes are accessed via:
```{r, eval = TRUE}
attributes(HiC_ctrl.cmx_lst)
#>
```

1. **names** : the names of list elements (ContactMatrix).
2. **resolution** : the resolution of the HiC map.  
3. **chromSize** : the size of the chromosomes in the tibble format.   
    - *seqnames* : the sequence name (chromosome name).  
    - *seqlengths* : the sequence length in base pairs.  
    - *dimension* : the sequence length in base bins  
4. **matricesKind** : the kind of matrix that composes the list in the tibble format.   
    - *name* : the matrix name. 
    - *type* : interaction type. *"Cis"* for interactions on the same chromosome and *"Trans"* for interactions on different chromosomes.  
    - *kind* : the matrix kind. U for upper triangle matrices, L for lower triangle matrices, NA for rectangular or square matrices. See  
    - *symmetric* : a boolean that indicates whether the matrix is symmetric (lower triangle identical to upper triangle).  
5. **mtx** : the kind of values in matrix. For exemple observed counts, normalized counts, observed/expected, etc.

Each contactmatrix in the list have metadata. These are accessed via:
```{r, eval = TRUE}
S4Vectors::metadata(HiC_ctrl.cmx_lst[["2L_2L"]])
#>
```


# Genomic locations Preprocess
Cette partie des données correspond aux données de positionnement sur le génomes. 
Pour les intégréer avec les données HiC qui sont représentée par des matrices (2D), ces données  doivent subire quelque transformations.

## Features Indexing
La première étape est l'indexation des features sur le génome. Cette étape permet de découper et regrouper les dans des bin qui correspondent à la résolution de la matrice HiC.
```{r, eval = TRUE, results = FALSE}
Beaf_Index.gnr <- IndexFeatures(
  gRange.gnr_lst        = list(Beaf = anchors_Peaks.gnr),
  constraint.gnr        = domains.gnr,
  chromSize.dtf         = chromSize.dtf,
  binSize.num           = binSize.num
  )
```

## Beaf32-TSS putatives pairing
La seconde étapes consiste à rechercher les paires de Bins 
```{r, eval = TRUE, results = FALSE}
Beaf_Pairs.gni <- SearchPairs(
  indexAnchor.gnr = Beaf_Index.gnr,
  minDist.num     = 40000,
  maxDist.num     = 100000
  )
```

# Aggregation Analysis

## Extraction
```{r, eval = TRUE, results = FALSE}
Beaf.mtx_lst <- ExtractSubmatrix(
  feature.gn  = Beaf_Pairs.gni,
  hic.cmx_lst = hic.cmx_lst
  )
```


## Aggregation
```{r, eval = TRUE, message = FALSE}
aggreg.mtx <- Aggregation(Beaf.mtx_lst)
```
## Visulatisation
```{r, eval = TRUE, fig.dim = c(7,7), warning=FALSE}
ggAPA(
  apa.mtx = aggreg.mtx,
  title.chr = "APA Beaf <-> Beaf"
  )
```
