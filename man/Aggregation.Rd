% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Aggregation.r
\name{Aggregation}
\alias{Aggregation}
\title{Aggregated matrices list.}
\usage{
Aggregation(
  ctrlMatrices.lst = NULL,
  matrices.lst = NULL,
  minDist.num = NULL,
  maxDist.num = NULL,
  trans.fun = NULL,
  agg.fun = "mean",
  rm0.bln = FALSE,
  diff.fun = "substraction",
  scaleCorrection.bln = FALSE,
  correctionArea.lst = NULL,
  statCompare.bln = FALSE
)
}
\arguments{
\item{ctrlMatrices.lst}{<list[matrix]>: The matrices list to aggregate as control.}

\item{matrices.lst}{<list[matrix]>: The matrices list to aggregate.}

\item{minDist.num}{<numeric>: The minimal distance between anchor and bait.}

\item{maxDist.num}{<numeric>: The maximal distance between anchor and bait.}

\item{trans.fun}{<chracter or function>: The function use to transforme or scale values in each submatrix before aggregation. If the parameter is character so:
\itemize{
\item "quantile" or "qtl" apply function dplyr::ntile(x,500)
\item "percentile" or "prct" apply percentile on values in matrix
\item "rank" apply a ranking on values in matrix
\item "zscore" apply a scaling on values in matrix
\item "minmax" apply a MinMaxScale on values in matrix
\item "mu" apply a MeanScale on values in matrix
\item other (Default) apply a log2 on 1+ratio
}}

\item{agg.fun}{<chracter or function>: The function use to aggregate each pixel in matrix. If the parameter is a character so:
\itemize{
\item "50%" or "median" apply the median
\item "+" or "sum" apply the sum
\item other (Default) apply the mean
}}

\item{rm0.bln}{<logical>: if TURE 0 are replace with NA. (Default FALSE)}

\item{diff.fun}{<chracter or function>: The function use to compute differential. If the parameter is character so:
\itemize{
\item "-", "substract" or "substraction" apply a substraction
\item "/" or "ratio" apply a ratio
\item "log2","log2-","log2/" or "log2ratio" apply a log2 on ratio
\item other (Default) apply a log2 on 1+ratio
}}

\item{scaleCorrection.bln}{<logical>: Whether a correction should be done on the median value take in ane noising area. (Default TRUE)}

\item{correctionArea.lst}{<list>: Nested list of indice that define a noising area fore correction. List muste contain in first an element "i" (row indices) then an element called "j" (columns indices). If NULL automatically take in upper left part of aggregated matrices. (Default NULL)}

\item{statCompare.bln}{<logical>: Whether a t.test must be apply to each pxl of the differential aggregated matrix.}
}
\value{
A matrix
}
\description{
Aggregated matrices list. Could apply a differential of each paired matrices in two list before and after aggregation.
}
\details{
Aggregation
}
\examples{
\dontrun{
# Classical Aggregation
# submatrixRF_Ctrl.mtx_lst is a submatrix list obtain with ExtractSubmatrix function
aggreg.mtx <- Aggregation(
  matrices.lst = submatrixRF_Ctrl.mtx_lst, 
  agg.fun      = "sum",
  trans.fun    = "qtl", 
  rm0.bln      = TRUE,
  minDist      = 9000,
  maxDist      = 11000
)

# Differential Aggregation
# submatrixRF.mtx_lst is a second submatrix list obtain with ExtractSubmatrix function
diffAggreg.mtx <- Aggregation(
  ctrlMatrices.lst    = submatrixRF_Ctrl.mtx_lst,
  matrices.lst        = submatrixRF.mtx_lst,
  minDist             = 9000,
  maxDist             = 11000,
  agg.fun             = "mean",
  rm0.bln             = FALSE,
  diff.fun            = "substraction",
  scaleCorrection.bln = TRUE,
  correctionArea.lst  =  list(
    i = c(1:30),
    j = c(72:101)
    ),
  statCompare.bln = TRUE
)
}
}
